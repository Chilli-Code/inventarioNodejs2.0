

<%- include('./chartSellUsers/contentHeader', {salesByUser, allUsers, isMobile}) %>


<script>
const rawData = <%- JSON.stringify(salesByUser || []) %>;
const safeData = Array.isArray(rawData) ? rawData : [];


const productsRawData = <%- JSON.stringify(productsByUser || []) %>;
const productsDataUser = Array.isArray(productsRawData) ? productsRawData : [];


// Variables globales - agregadas a tu lógica original
let chart;
let filteredData = [...safeData];
let currentPage = 1;
let itemsPerPage = 10;

// Tu función original mejorada
function getChartData(arr) {
  return {
    labels: arr.map(item =>
      item.user && item.user.nombre 
        ? item.user.nombre 
        : `Usuario ${item._id.slice(0,6)}...`),
    data: arr.map(item => Number(item.totalVentas) || 0)
  }
}

// Función para obtener datos paginados
function getPaginatedData() {
  if (itemsPerPage === -1) return filteredData;
  
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  return filteredData.slice(startIndex, endIndex);
}

// Función mejorada para crear/actualizar el chart
function createOrUpdateChart() {
    const canvasEl = document.getElementById('salesChart');
  if (!canvasEl) {
    console.warn('Canvas #salesChart no encontrado. El chart no se inicializará.');
    return;
  }
  const paginatedData = getPaginatedData();
 const chartType = document.getElementById('chartType')?.value || 'bar'; 
  const {labels, data} = getChartData(paginatedData);
  
  // const ctx = document.getElementById('salesChart').getContext('2d');
   const ctx = canvasEl.getContext('2d');
  
  if (chart) {
    // Si ya existe el chart, solo actualizamos los datos
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.data.datasets[0].backgroundColor = generateGradientColors(ctx, data.length, chartType);
    
    // Si cambió el tipo de gráfica, destruimos y creamos nuevo
    if (chart.config.type !== chartType) {
      chart.destroy();
      chart = createNewChart(ctx, chartType, labels, data);
    } else {
      chart.update();
    }
  } else {
    // Crear nuevo chart
    chart = createNewChart(ctx, chartType, labels, data);
  }
}

// Función para crear un nuevo chart
function createNewChart(ctx, chartType, labels, data) {
  return new Chart(ctx, {
    type: chartType,
    data: {
      labels,
      datasets: [{
        label: 'Ventas por usuario',
        data,
        backgroundColor: generateGradientColors(ctx, data.length, chartType),
        borderColor: '#667eea',
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: chartType === 'pie' || chartType === 'doughnut',
          labels: {
            color: '#333',
            font: {
              size: 12,
              weight: '600'
            }
          }
        }
      },
      scales: chartType === 'bar' || chartType === 'horizontalBar' ? {
        y: { 
          beginAtZero: true,
          ticks: {
            callback: function(value) {
              return '$' + value.toLocaleString();
            },
            color: '#666',
            font: {
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(102, 126, 234, 0.1)'
          }
        },
        x: {
          ticks: {
            color: '#666',
            font: {
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(102, 126, 234, 0.1)'
          }
        }
      } : {}
    }
  });
}

// Función para generar gradientes
function generateGradientColors(ctx, count, chartType) {
  const gradients = [];
  const baseColors = [
    ['#667eea', '#764ba2'],
    ['#f093fb', '#f5576c'],
    ['#4facfe', '#00f2fe'],
    ['#43e97b', '#38f9d7'],
    ['#fa709a', '#fee140'],
    ['#a8edea', '#fed6e3'],
    ['#ffecd2', '#fcb69f'],
    ['#ff9a9e', '#fecfef'],
    ['#fecfef', '#fecfef'],
    ['#96fbc4', '#f9f586']
  ];
  
  for (let i = 0; i < count; i++) {
    const colorPair = baseColors[i % baseColors.length];
    
    if (chartType === 'pie' || chartType === 'doughnut') {
      gradients.push(colorPair[0]);
    } else {
      const gradient = ctx.createLinearGradient(0, 0, 0, 400);
      gradient.addColorStop(0, colorPair[0]);
      gradient.addColorStop(1, colorPair[1]);
      gradients.push(gradient);
    }
  }
  
  return gradients;
}

// Función para aplicar filtros (mejorada)
function applyFilters() {
  const selected = document.getElementById('userFilter').value;
  const sortOrder = document.getElementById('sortOrder').value;
  const minSales = parseFloat(document.getElementById('minSales').value) || 0;
  const statusFilter = document.getElementById('statusFilter').value;

  // Tu lógica original de filtro por usuario
  filteredData = selected
    ? safeData.filter(item => (item.user && item.user._id) === selected || item._id === selected)
    : [...safeData];

  // Filtrar por ventas mínimas
  filteredData = filteredData.filter(item => (Number(item.totalVentas) || 0) >= minSales);
  // AGREGAR ESTE FILTRO POR ESTADO:
  if (statusFilter !== '') {
    const isActive = statusFilter === 'true';
    filteredData = filteredData.filter(item => item.active === isActive);
  }
  // Ordenar
  filteredData.sort((a, b) => {
    switch(sortOrder) {
      case 'asc':
        return (Number(a.totalVentas) || 0) - (Number(b.totalVentas) || 0);
      case 'desc':
        return (Number(b.totalVentas) || 0) - (Number(a.totalVentas) || 0);
      case 'name':
        const nameA = a.user?.nombre || `Usuario ${a._id}`;
        const nameB = b.user?.nombre || `Usuario ${b._id}`;
        return nameA.localeCompare(nameB);
      default:
        return (Number(b.totalVentas) || 0) - (Number(a.totalVentas) || 0);
    }
  });

  currentPage = 1;
  createOrUpdateChart();
  updateStats();
  updatePagination();
}


// NUEVA FUNCIÓN: Calcular total de productos vendidos (unidades) basado en filteredData
function calculateTotalProductosVendidos() {
  // Obtener IDs de usuarios en el filtro actual
  const userIdsInFilter = filteredData.map(item => item._id).filter(id => id);
  
  if (userIdsInFilter.length === 0) {
    // Si no hay filtro, usar total global
return 0;  
}
  
  // Filtrar productsDataUser por usuarios en filteredData (ej. solo Carlos)
  const filteredProducts = productsDataUser.filter(item => 
    userIdsInFilter.includes(item._id.toString())
  );
  
  // Sumar totalVentas (unidades vendidas por usuario)
  return filteredProducts.reduce((sum, item) => sum + (Number(item.totalVentas) || 0), 0);
}



// Función para actualizar estadísticas
function updateStats() {
  const totalUsers = filteredData.length;
  const totalSales = filteredData.reduce((sum, item) => sum + (Number(item.totalVentas) || 0), 0);
  const averageSales = totalUsers > 0 ? totalSales / totalUsers : 0;  // Cambié a totalUsers para promedio por usuario


    // NUEVO: Total de productos vendidos (unidades), filtrado o global
  const totalProductosVendidos = calculateTotalProductosVendidos();  // Ej. 45 si filtras Carlos


  // CAMBIO: Filtrar solo usuarios que tengan la propiedad 'user'
  const validUsers = safeData.filter(item => item.user && item.user.nombre);
  
  
  let topSeller = '-';
  if (validUsers.length > 0) {
    const bestUser = validUsers.reduce((top, current) => 
      (Number(current.totalVentas) || 0) > (Number(top.totalVentas) || 0) ? current : top
    );
    topSeller = bestUser.user.nombre;
  }

  animateValue('totalUsers', 0, totalUsers, 1000);
  animateValue('totalSales', 0, totalSales, 1000, '$');
  animateValue('averageSales', 0, Math.round(averageSales), 1000, '$');
  animateValue('totalVentas', 0, totalProductosVendidos, 1000);

  document.getElementById('topSeller').textContent = topSeller;
}

// Función para animar valores
function animateValue(elementId, start, end, duration, prefix = '') {
  const element = document.getElementById(elementId);
  const startTime = performance.now();
  
  function update(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    const current = Math.floor(start + (end - start) * progress);
    element.textContent = prefix + current.toLocaleString();
    
    if (progress < 1) {
      requestAnimationFrame(update);
    }
  }
  
  requestAnimationFrame(update);
}

// Función para actualizar paginación
function updatePagination() {
  if (itemsPerPage === -1) {
    document.querySelector('.pagination-controls').style.display = 'none';
    return;
  }

  document.querySelector('.pagination-controls').style.display = 'flex';
  
  const totalPages = Math.ceil(filteredData.length / itemsPerPage);
  
  document.getElementById('pageInfo').textContent = 
    `Página ${currentPage} de ${totalPages}`;
  
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  
  prevBtn.disabled = currentPage <= 1;
  nextBtn.disabled = currentPage >= totalPages;
  
  // Actualizar estilos
  if (prevBtn.disabled) {
    prevBtn.style.background = 'linear-gradient(135deg, #6c757d 0%, #5a6268 100%)';
    prevBtn.style.cursor = 'not-allowed';
  } else {
    prevBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    prevBtn.style.cursor = 'pointer';
  }
  
  if (nextBtn.disabled) {
    nextBtn.style.background = 'linear-gradient(135deg, #6c757d 0%, #5a6268 100%)';
    nextBtn.style.cursor = 'not-allowed';
  } else {
    nextBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    nextBtn.style.cursor = 'pointer';
  }
}

// Función para cambiar página
function changePage(direction) {
  const totalPages = Math.ceil(filteredData.length / itemsPerPage);
  currentPage += direction;
  
  if (currentPage < 1) currentPage = 1;
  if (currentPage > totalPages) currentPage = totalPages;
  
  createOrUpdateChart();
  updatePagination();
}

// Inicialización (tu código original mejorado)
const ctx = document.getElementById('salesChart').getContext('2d');
filteredData = [...safeData];
createOrUpdateChart();
updateStats();
updatePagination();

// Tus event listeners originales + los nuevos
document.getElementById('userFilter').addEventListener('change', applyFilters);
document.getElementById('chartType').addEventListener('change', createOrUpdateChart);
document.getElementById('sortOrder').addEventListener('change', applyFilters);
document.getElementById('itemsPerPage').addEventListener('change', function() {
  itemsPerPage = parseInt(this.value);
  currentPage = 1;
  createOrUpdateChart();
  updatePagination();
});
document.getElementById('minSales').addEventListener('input', applyFilters);
document.getElementById('prevPage').addEventListener('click', () => changePage(-1));
document.getElementById('nextPage').addEventListener('click', () => changePage(1));
document.getElementById('statusFilter').addEventListener('change', applyFilters);
// Agregar efectos hover para las cards
document.querySelectorAll('.stat-card').forEach(card => {
  card.addEventListener('mouseenter', function() {
    this.style.transform = 'translateY(-5px) scale(1.02)';
  });
  card.addEventListener('mouseleave', function() {
    this.style.transform = 'translateY(0) scale(1)';
  });
});

// Efectos hover para botones
document.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('mouseenter', function() {
    if (!this.disabled) {
      this.style.transform = 'translateY(-2px)';
      this.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.4)';
    }
  });
  btn.addEventListener('mouseleave', function() {
    this.style.transform = 'translateY(0)';
    this.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.3)';
  });
});

// Estilos CSS adicionales
document.head.insertAdjacentHTML('beforeend', `
<style>
  select:focus, input:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    transform: translateY(-1px);
  }
  
  #salesChart {
    height: 400px !important;
  }
</style>
`);
</script>


<script>
  // Función para detectar móvil (simple con matchMedia)
  function isMobile() {
    return window.matchMedia("(max-width: 768px)").matches;
  }

  const toggleBtn = document.getElementById('toggleFiltersBtn');
  const filtersDiv = document.getElementById('filtersDiv');

  function setupFiltersToggle() {
    if (isMobile()) {
      // En móvil: ocultamos filtros y mostramos botón
      filtersDiv.style.display = 'none';
      toggleBtn.style.display = 'inline-block';

      toggleBtn.textContent = 'Mostrar filtros';

      toggleBtn.onclick = () => {
        if (filtersDiv.style.display === 'none') {
          filtersDiv.style.display = 'block';
          toggleBtn.textContent = 'Ocultar filtros';
        } else {
          filtersDiv.style.display = 'none';
          toggleBtn.textContent = 'Mostrar filtros';
        }
      };
    } else {
      // En desktop: siempre mostrar filtros y ocultar botón
      filtersDiv.style.display = 'flex';
      toggleBtn.style.display = 'none';
    }
  }
  // Ejecutar al cargar la página
  setupFiltersToggle();
  // También ajustar si cambian el tamaño de ventana (opcional)
  window.addEventListener('resize', setupFiltersToggle);
</script>